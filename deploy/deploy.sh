#!/usr/bin/env bash
set -euo pipefail

# One-click deploy script for Armbian VPS (Docker + nginx + certbot)
# Usage: sudo ./deploy.sh --domain example.com --email admin@example.com

WORKDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ENV_FILE="$WORKDIR/.env.production"
NGINX_SITE="/etc/nginx/sites-available/8ehradioitb"
CERTBOT_WEBROOT="/var/www/certbot"

print_usage(){
  cat <<EOF
Usage: sudo $0 --domain <domain> --email <email>

This script will:
 - ensure docker and docker compose plugin are installed
 - create .env.production (prompting for missing values)
 - build and run docker compose
 - install nginx site and reload
 - obtain Let's Encrypt certificates via certbot

EOF
}

# Parse args
DOMAIN=""
EMAIL=""
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    --domain) DOMAIN="$2"; shift 2;;
    --email) EMAIL="$2"; shift 2;;
    -h|--help) print_usage; exit 0;;
    *) echo "Unknown arg: $1"; print_usage; exit 1;;
  esac
done

if [[ -z "$DOMAIN" || -z "$EMAIL" ]]; then
  echo "Domain and email are required."; print_usage; exit 1
fi

# ensure running as root for nginx and apt actions
if [[ $EUID -ne 0 ]]; then
  echo "This script should be run as root or via sudo."; exit 1
fi

# Install docker if missing
if ! command -v docker >/dev/null 2>&1; then
  echo "Docker not found. Installing..."
  curl -fsSL https://get.docker.com | sh
fi

# Install docker compose plugin if missing
if ! docker compose version >/dev/null 2>&1; then
  echo "Installing docker compose plugin..."
  apt-get update && apt-get install -y docker-compose-plugin
fi

# Create .env.production from machine env or prompt
echo "Creating $ENV_FILE"
cat > "$ENV_FILE" <<EOF
# Generated by deploy.sh
MONGODB_URL=${MONGODB_URL:-mongodb://mongo:27017/8ehradio}
NEXTAUTH_URL=https://$DOMAIN
NEXTAUTH_SECRET=${NEXTAUTH_SECRET:-}
NEXT_PUBLIC_SITE_URL=https://$DOMAIN
NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME:-}
NEXT_PUBLIC_CLOUDINARY_UPLOAD_PRESET=${NEXT_PUBLIC_CLOUDINARY_UPLOAD_PRESET:-}
R2_ENDPOINT=${R2_ENDPOINT:-}
R2_ACCESS_KEY_ID=${R2_ACCESS_KEY_ID:-}
R2_SECRET_ACCESS_KEY=${R2_SECRET_ACCESS_KEY:-}
R2_BUCKET=${R2_BUCKET:-}
R2_PUBLIC_DEV_URL=${R2_PUBLIC_DEV_URL:-}
GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID:-}
GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET:-}
EOF

# If NEXTAUTH_SECRET empty, generate one
if ! grep -q "^NEXTAUTH_SECRET=" "$ENV_FILE" || [[ "$(sed -n 's/^NEXTAUTH_SECRET=//p' $ENV_FILE)" == "" ]]; then
  SECRET=$(openssl rand -hex 32)
  sed -i "s/^NEXTAUTH_SECRET=.*/NEXTAUTH_SECRET=$SECRET/" "$ENV_FILE"
  echo "Generated NEXTAUTH_SECRET"
fi

# Build and run docker-compose
cd "$WORKDIR"
echo "Building and starting containers..."
# decide whether to start local mongo. Read MONGODB_URL from env file we just created
MONGODB_URL_VALUE=$(sed -n 's/^MONGODB_URL=//p' "$ENV_FILE" | tr -d '\r')
# normalize empty
MONGODB_URL_VALUE=${MONGODB_URL_VALUE:-}

# determine if URL refers to local container mongo (host contains "mongo" or host is localhost/127.0.0.1)
START_MONGO=false
if [[ -z "$MONGODB_URL_VALUE" ]]; then
  # default value points to local mongo
  START_MONGO=true
elif echo "$MONGODB_URL_VALUE" | grep -q "@"; then
  # connection string with creds containing @, leave as remote
  START_MONGO=false
else
  # check host part
  HOST_PART=$(echo "$MONGODB_URL_VALUE" | sed -E 's#^[^:]+://([^/:]+).*#\1#') || true
  if [[ "$HOST_PART" == "mongo" || "$HOST_PART" == "localhost" || "$HOST_PART" == "127.0.0.1" ]]; then
    START_MONGO=true
  else
    START_MONGO=false
  fi
fi

if [[ "$START_MONGO" == true ]]; then
  echo "Starting app + mongo (local)"
  docker compose --env-file "$ENV_FILE" -f docker-compose.yml -f docker-compose.mongo.yml up -d --build
else
  echo "Starting app only (using remote MongoDB)"
  docker compose --env-file "$ENV_FILE" -f docker-compose.yml up -d --build
fi

# Setup nginx site
mkdir -p "$CERTBOT_WEBROOT"
cat > "$NGINX_SITE" <<'NGCONF'
server {
    listen 80;
    server_name _DOMAIN_;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        allow all;
    }

    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_read_timeout 90;
    }
}
NGCONF

# replace placeholder domain
sed -i "s/_DOMAIN_/$DOMAIN/g" "$NGINX_SITE"
# enable site
ln -sf "$NGINX_SITE" /etc/nginx/sites-enabled/8ehradioitb

# test nginx config and reload
if nginx -t; then
  systemctl reload nginx
else
  echo "nginx config test failed; check $NGINX_SITE"; exit 1
fi

# Install certbot and obtain cert
if ! command -v certbot >/dev/null 2>&1; then
  apt-get update
  apt-get install -y certbot python3-certbot-nginx
fi

certbot --nginx -d "$DOMAIN" -m "$EMAIL" --non-interactive --agree-tos || {
  echo "certbot failed. You may need to run certbot manually.";
}

# Final status
echo "Deployment finished. Visit https://$DOMAIN"

echo "To view logs: docker compose logs -f app"
